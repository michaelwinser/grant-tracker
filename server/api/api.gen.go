//go:build go1.22

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
)

const (
	SessionCookieScopes = "sessionCookie.Scopes"
)

// Defines values for CreateDocRequestMimeType.
const (
	ApplicationvndGoogleAppsDocument     CreateDocRequestMimeType = "application/vnd.google-apps.document"
	ApplicationvndGoogleAppsPresentation CreateDocRequestMimeType = "application/vnd.google-apps.presentation"
	ApplicationvndGoogleAppsSpreadsheet  CreateDocRequestMimeType = "application/vnd.google-apps.spreadsheet"
)

// AppendRowRequest defines model for AppendRowRequest.
type AppendRowRequest struct {
	// Row Row data as key-value pairs where keys match column headers
	Row map[string]interface{} `json:"row"`

	// Sheet Sheet name
	Sheet string `json:"sheet"`
}

// BatchUpdateRequest defines model for BatchUpdateRequest.
type BatchUpdateRequest struct {
	// Sheet Sheet name
	Sheet   string `json:"sheet"`
	Updates []struct {
		// Range Cell range (e.g., 'A2:C2')
		Range string `json:"range"`

		// Values Values to set in the range
		Values []interface{} `json:"values"`
	} `json:"updates"`
}

// Config defines model for Config.
type Config struct {
	// ClientId Google OAuth client ID
	ClientId string `json:"clientId"`

	// GrantsFolderId ID of the grants root folder (only when service account enabled)
	GrantsFolderId *string `json:"grantsFolderId,omitempty"`

	// ServiceAccountEnabled Whether service account API is available
	ServiceAccountEnabled bool `json:"serviceAccountEnabled"`

	// SpreadsheetId ID of the Grant Tracker spreadsheet (only when service account enabled)
	SpreadsheetId *string `json:"spreadsheetId,omitempty"`
}

// CreateDocRequest defines model for CreateDocRequest.
type CreateDocRequest struct {
	// MimeType Document type
	MimeType CreateDocRequestMimeType `json:"mimeType"`

	// Name Document name
	Name string `json:"name"`

	// ParentId Parent folder ID
	ParentId *string `json:"parentId,omitempty"`
}

// CreateDocRequestMimeType Document type
type CreateDocRequestMimeType string

// CreateDocResponse defines model for CreateDocResponse.
type CreateDocResponse struct {
	// Id Created document ID
	Id string `json:"id"`

	// Url URL to view/edit the document
	Url string `json:"url"`
}

// CreateFolderRequest defines model for CreateFolderRequest.
type CreateFolderRequest struct {
	// Name Folder name
	Name string `json:"name"`

	// ParentId Parent folder ID (defaults to grants folder)
	ParentId *string `json:"parentId,omitempty"`
}

// CreateFolderResponse defines model for CreateFolderResponse.
type CreateFolderResponse struct {
	// Id Created folder ID
	Id string `json:"id"`

	// Url URL to view the folder
	Url string `json:"url"`
}

// CreateShortcutRequest defines model for CreateShortcutRequest.
type CreateShortcutRequest struct {
	// Name Optional shortcut name (defaults to target's name)
	Name *string `json:"name,omitempty"`

	// ParentId Folder to create the shortcut in
	ParentId string `json:"parentId"`

	// TargetId ID of the file to create a shortcut to
	TargetId string `json:"targetId"`
}

// CreateShortcutResponse defines model for CreateShortcutResponse.
type CreateShortcutResponse struct {
	// Id Created shortcut ID
	Id string `json:"id"`
}

// DeleteRowRequest defines model for DeleteRowRequest.
type DeleteRowRequest struct {
	// Id Value of the ID to match
	Id string `json:"id"`

	// IdColumn Column name containing the unique ID
	IdColumn string `json:"idColumn"`

	// Sheet Sheet name
	Sheet string `json:"sheet"`
}

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// FileInfo defines model for FileInfo.
type FileInfo struct {
	// Id File ID
	Id string `json:"id"`

	// MimeType MIME type
	MimeType string `json:"mimeType"`

	// ModifiedTime Last modified timestamp
	ModifiedTime *time.Time `json:"modifiedTime,omitempty"`

	// Name File name
	Name            string           `json:"name"`
	ShortcutDetails *ShortcutDetails `json:"shortcutDetails,omitempty"`

	// WebViewLink URL to view the file in browser
	WebViewLink *string `json:"webViewLink,omitempty"`
}

// GetFileRequest defines model for GetFileRequest.
type GetFileRequest struct {
	// FileId ID of the file to get
	FileId string `json:"fileId"`
}

// ListFilesRequest defines model for ListFilesRequest.
type ListFilesRequest struct {
	// FolderId Folder ID to list (defaults to grants folder)
	FolderId *string `json:"folderId,omitempty"`

	// Query Additional Drive API query filter
	Query *string `json:"query,omitempty"`
}

// ListFilesResponse defines model for ListFilesResponse.
type ListFilesResponse struct {
	Files []FileInfo `json:"files"`
}

// MoveFileRequest defines model for MoveFileRequest.
type MoveFileRequest struct {
	// FileId ID of the file to move
	FileId string `json:"fileId"`

	// NewParentId ID of the new parent folder
	NewParentId string `json:"newParentId"`

	// PrevParentId ID of the previous parent folder (optional, will be detected if not provided)
	PrevParentId *string `json:"prevParentId,omitempty"`
}

// ReadSheetRequest defines model for ReadSheetRequest.
type ReadSheetRequest struct {
	// Range Optional range (e.g., 'A1:Z')
	Range *string `json:"range,omitempty"`

	// Sheet Sheet name (e.g., 'Grants', 'ActionItems')
	Sheet string `json:"sheet"`
}

// ReadSheetResponse defines model for ReadSheetResponse.
type ReadSheetResponse struct {
	// Headers Column headers from first row
	Headers []string `json:"headers"`

	// Rows Data rows (excluding header row)
	Rows [][]interface{} `json:"rows"`
}

// ShortcutDetails defines model for ShortcutDetails.
type ShortcutDetails struct {
	// TargetId ID of the file this shortcut points to
	TargetId *string `json:"targetId,omitempty"`

	// TargetMimeType MIME type of the target file
	TargetMimeType *string `json:"targetMimeType,omitempty"`
}

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	Success bool `json:"success"`
}

// UpdateRowRequest defines model for UpdateRowRequest.
type UpdateRowRequest struct {
	// Data Fields to update as key-value pairs
	Data map[string]interface{} `json:"data"`

	// Id Value of the ID to match
	Id string `json:"id"`

	// IdColumn Column name containing the unique ID
	IdColumn string `json:"idColumn"`

	// Sheet Sheet name
	Sheet string `json:"sheet"`
}

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// InternalError defines model for InternalError.
type InternalError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// CreateDocJSONRequestBody defines body for CreateDoc for application/json ContentType.
type CreateDocJSONRequestBody = CreateDocRequest

// CreateFolderJSONRequestBody defines body for CreateFolder for application/json ContentType.
type CreateFolderJSONRequestBody = CreateFolderRequest

// CreateShortcutJSONRequestBody defines body for CreateShortcut for application/json ContentType.
type CreateShortcutJSONRequestBody = CreateShortcutRequest

// GetFileJSONRequestBody defines body for GetFile for application/json ContentType.
type GetFileJSONRequestBody = GetFileRequest

// ListFilesJSONRequestBody defines body for ListFiles for application/json ContentType.
type ListFilesJSONRequestBody = ListFilesRequest

// MoveFileJSONRequestBody defines body for MoveFile for application/json ContentType.
type MoveFileJSONRequestBody = MoveFileRequest

// AppendRowJSONRequestBody defines body for AppendRow for application/json ContentType.
type AppendRowJSONRequestBody = AppendRowRequest

// BatchUpdateCellsJSONRequestBody defines body for BatchUpdateCells for application/json ContentType.
type BatchUpdateCellsJSONRequestBody = BatchUpdateRequest

// DeleteRowJSONRequestBody defines body for DeleteRow for application/json ContentType.
type DeleteRowJSONRequestBody = DeleteRowRequest

// ReadSheetJSONRequestBody defines body for ReadSheet for application/json ContentType.
type ReadSheetJSONRequestBody = ReadSheetRequest

// UpdateRowJSONRequestBody defines body for UpdateRow for application/json ContentType.
type UpdateRowJSONRequestBody = UpdateRowRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get application configuration
	// (GET /config)
	GetConfig(w http.ResponseWriter, r *http.Request)
	// Create a document
	// (POST /drive/create-doc)
	CreateDoc(w http.ResponseWriter, r *http.Request)
	// Create a folder
	// (POST /drive/create-folder)
	CreateFolder(w http.ResponseWriter, r *http.Request)
	// Create a shortcut
	// (POST /drive/create-shortcut)
	CreateShortcut(w http.ResponseWriter, r *http.Request)
	// Get file metadata
	// (POST /drive/get)
	GetFile(w http.ResponseWriter, r *http.Request)
	// List files in a folder
	// (POST /drive/list)
	ListFiles(w http.ResponseWriter, r *http.Request)
	// Move a file
	// (POST /drive/move)
	MoveFile(w http.ResponseWriter, r *http.Request)
	// Append a row to a sheet
	// (POST /sheets/append)
	AppendRow(w http.ResponseWriter, r *http.Request)
	// Batch update multiple cells
	// (POST /sheets/batch-update)
	BatchUpdateCells(w http.ResponseWriter, r *http.Request)
	// Delete a row from a sheet
	// (POST /sheets/delete)
	DeleteRow(w http.ResponseWriter, r *http.Request)
	// Read data from a sheet
	// (POST /sheets/read)
	ReadSheet(w http.ResponseWriter, r *http.Request)
	// Update a row in a sheet
	// (POST /sheets/update)
	UpdateRow(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetConfig operation middleware
func (siw *ServerInterfaceWrapper) GetConfig(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConfig(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateDoc operation middleware
func (siw *ServerInterfaceWrapper) CreateDoc(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateDoc(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateFolder operation middleware
func (siw *ServerInterfaceWrapper) CreateFolder(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateFolder(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateShortcut operation middleware
func (siw *ServerInterfaceWrapper) CreateShortcut(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateShortcut(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFile operation middleware
func (siw *ServerInterfaceWrapper) GetFile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListFiles operation middleware
func (siw *ServerInterfaceWrapper) ListFiles(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListFiles(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// MoveFile operation middleware
func (siw *ServerInterfaceWrapper) MoveFile(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.MoveFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AppendRow operation middleware
func (siw *ServerInterfaceWrapper) AppendRow(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AppendRow(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// BatchUpdateCells operation middleware
func (siw *ServerInterfaceWrapper) BatchUpdateCells(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BatchUpdateCells(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteRow operation middleware
func (siw *ServerInterfaceWrapper) DeleteRow(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteRow(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReadSheet operation middleware
func (siw *ServerInterfaceWrapper) ReadSheet(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReadSheet(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateRow operation middleware
func (siw *ServerInterfaceWrapper) UpdateRow(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateRow(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/config", wrapper.GetConfig)
	m.HandleFunc("POST "+options.BaseURL+"/drive/create-doc", wrapper.CreateDoc)
	m.HandleFunc("POST "+options.BaseURL+"/drive/create-folder", wrapper.CreateFolder)
	m.HandleFunc("POST "+options.BaseURL+"/drive/create-shortcut", wrapper.CreateShortcut)
	m.HandleFunc("POST "+options.BaseURL+"/drive/get", wrapper.GetFile)
	m.HandleFunc("POST "+options.BaseURL+"/drive/list", wrapper.ListFiles)
	m.HandleFunc("POST "+options.BaseURL+"/drive/move", wrapper.MoveFile)
	m.HandleFunc("POST "+options.BaseURL+"/sheets/append", wrapper.AppendRow)
	m.HandleFunc("POST "+options.BaseURL+"/sheets/batch-update", wrapper.BatchUpdateCells)
	m.HandleFunc("POST "+options.BaseURL+"/sheets/delete", wrapper.DeleteRow)
	m.HandleFunc("POST "+options.BaseURL+"/sheets/read", wrapper.ReadSheet)
	m.HandleFunc("POST "+options.BaseURL+"/sheets/update", wrapper.UpdateRow)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
